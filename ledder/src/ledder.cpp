#include <SPI.h>
#include <DMD.h>
#include <TimerOne.h>
#include "SystemFont5x7.h"

#include <FixedPoints.h>
#include <FixedPointsCommon.h>

#include "glsl.h"

#define ROW 1
#define COLUMN 1
#define FONT1 Arial_Black_16_ISO_8859_1
#define LED_STEP 10

#define WIDTH (ROW * 16)
#define HEIGHT (COLUMN * 32)

using fp = SQ7x8;

const static fp SINE_TABLE [] PROGMEM = {
  0.0, 1.0
};

const static uint8_t FONT2[] PROGMEM = {
    0x00, 0x00, // fixed width font
    0xc, 0x10, // width, height
    0x40, // first char ("@")
    0xa, // char count
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, // @
    0x0,0xff,0xff,0x0,0x0,0x0,0x0,0xff,0xff,0x0,0x0,0x0,0x0,0x7,0xf,0xe,0xc,0xf,0xf,0xf,0xf,0x4,0x0,0x0, // A
    0x0,0xfc,0xfe,0x86,0x87,0x87,0x86,0xbe,0xbc,0x0,0x0,0x0,0x0,0x1f,0x1f,0x3,0x3,0x3,0x3,0x3,0x3,0x0,0x0,0x0, // B
    0x78,0xfe,0xfe,0x87,0x87,0x87,0xfe,0xfe,0xf8,0x80,0x0,0x0,0x0,0x1,0x1,0x3,0x3,0x3,0x1f,0x1f,0x1f,0x3,0x0,0x0, // C
    0x38,0x3e,0x3e,0x7,0x7,0x7,0xfe,0xfe,0xf8,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x1f,0x3,0x0,0x0, // D
    0x0,0xff,0xff,0x18,0x18,0x18,0x18,0x98,0x98,0x18,0x0,0x0,0x0,0x7,0xf,0xe,0xc,0xc,0xe,0xf,0x7,0x0,0x0,0x0, // E
    0x0,0x3c,0x3e,0x6,0x7,0x7,0x6,0xfe,0xfc,0x70,0x0,0x0,0x0,0x1c,0x1c,0x18,0x18,0x1c,0x1f,0x1b,0x19,0x0,0x0,0x0, // F
    0x0,0xff,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x0,0x0,0x0,0x0,0xf,0xf,0xc,0xc,0xc,0xc,0xc,0x0,0x0,0x0,0x0, // G
    0x0,0xfc,0xfe,0x6,0x7,0x7,0x6,0x3e,0x3c,0x0,0x0,0x0,0x0,0x1f,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x0,0x0,0x0, // H
    0xf0,0xfe,0xe,0x3,0xc3,0xc3,0xc6,0xfe,0xfc,0xc0,0x0,0x0,0x1f,0x1f,0x0,0x7,0x1f,0x18,0x18,0x1f,0xf,0x0,0x0,0x0, // I
};

// Header File for SSD1306 characters
// Font Size: 16
const static uint8_t FONT[] PROGMEM = {
    0x00, 0x00, // fixed width font
    0xc, 0x10, // width, height
    0x40, // first char ("@")
    0x13, // char count
    0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, // @
    0xff,0xff,0x0,0x0,0x0,0x0,0xff,0xff,0x0,0x0,0x0,0x0,0x7,0xf,0xe,0xc,0xc,0xe,0xf,0xf,0x1c,0x18,0x0,0x0, // A
    0xfc,0xfe,0x86,0x87,0x87,0x86,0xbe,0x3c,0x0,0x0,0x0,0x0,0x1f,0x1f,0x1,0x1,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0, // B
    0x78,0xfe,0xfe,0x87,0x87,0x87,0xfe,0xfe,0xf8,0x80,0x0,0x0,0x0,0x1,0x1,0x3,0x3,0x3,0x1f,0x1f,0x1f,0x3,0x0,0x0, // C
    0x38,0x3e,0x3e,0x7,0x7,0x7,0xfe,0xfe,0xf8,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x1f,0x3,0x0,0x0, // D
    0xff,0xff,0x18,0x18,0x18,0x18,0x98,0x98,0x18,0x0,0x0,0x0,0x7,0xf,0xe,0xc,0xc,0xe,0xf,0x7,0x0,0x0,0x0,0x0, // E
    0x3c,0x3e,0x6,0x7,0x7,0x6,0xfe,0xfc,0x70,0x0,0x0,0x0,0x1c,0x1c,0x18,0x18,0x1c,0x1f,0x1b,0x19,0x0,0x0,0x0,0x0, // F
    0xff,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x0,0x0,0x0,0x0,0xf,0xf,0xc,0xc,0xc,0xc,0xc,0x0,0x0,0x0,0x0,0x0, // G
    0xfc,0xfe,0x6,0x7,0x7,0x6,0x3e,0x3c,0x0,0x0,0x0,0x0,0x1f,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x0,0x0,0x0,0x0, // H
    0xf0,0xfe,0xe,0x3,0xc3,0xc3,0xc6,0xfe,0xfc,0xc0,0x0,0x0,0x1f,0x1f,0x0,0x7,0x1f,0x18,0x18,0x1f,0xf,0x0,0x0,0x0, // I
    0xc0,0xf0,0xf8,0x18,0x18,0x18,0xff,0xff,0xff,0x18,0x0,0x0,0x3,0x7,0xf,0xc,0xc,0xc,0xf,0x7,0x3,0x0,0x0,0x0, // J
    0xff,0xff,0x38,0x18,0x18,0x18,0xf8,0xf0,0x0,0x0,0x0,0x0,0xf,0xf,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, // K
    0xff,0xff,0xff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf,0xf,0xf,0xc,0xc,0xc,0xc,0xc,0x0,0x0,0x0,0x0, // L
    0xff,0xff,0x18,0xf8,0xf8,0x0,0xf8,0xf8,0xf8,0x0,0x0,0x0,0xf,0xf,0x0,0x7,0xf,0xc,0xf,0xf,0x3,0x0,0x0,0x0, // M
    0x1e,0xfe,0xf8,0x3c,0x1e,0x1e,0x1f,0xfb,0xf6,0xc6,0x0,0x0,0x0,0x7,0x1f,0x1c,0x18,0x18,0x18,0x1f,0xf,0x7,0x0,0x0, // N
    0x7f,0xff,0xc0,0x80,0x80,0xc0,0xf8,0xf8,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x1,0xf,0xf,0x0,0x0,0x0,0x0, // O
    0xc0,0xe0,0xf0,0x38,0x19,0x1f,0xf,0xe,0x0,0x0,0x0,0x0,0x1,0x3,0x3,0x7,0x7,0x6,0xe,0xc,0x1c,0x0,0x0,0x0, // P
    0x3c,0x3e,0x6,0x7,0x7,0x6,0xfe,0xfc,0x20,0x0,0x0,0x0,0x1f,0x1f,0x1b,0x1b,0x1f,0xf,0x1f,0x1b,0x0,0x0,0x0,0x0, // Q
    0x38,0x3e,0x3e,0x7,0x7,0x7,0xfe,0xfe,0xf8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1f,0x1f,0x1f,0x18,0x0,0x0, // R
};



DMD led_module(ROW, COLUMN);

void scan_module() {
  led_module.scanDisplayBySPI();
}

// 40 mm encoder = 320 mm led = 32 marquee step = 32 pulses

uint32_t encoder_steps = 0;
void handle_encoder() {
  encoder_steps++;
}

void setup() {
  Timer1.initialize(500);
  Timer1.attachInterrupt(scan_module);
  led_module.clearScreen(true);

  analogWrite(9, 255);
  attachInterrupt(digitalPinToInterrupt(2), handle_encoder, CHANGE);
}

float led_mm = 0;

uint32_t t = 0;
int32_t uv_x_offset = WIDTH;

vec2 center_1;
vec2 center_2;
vec2 center_3;

int16_t r_1;
int16_t r_2;
int16_t r_3;

int16_t sp_1(vec2 uv) {
  return sphere(center_1, uv, r_1);
}

int16_t sp_2(vec2 uv) {
  return sphere(center_2, uv, r_2);
}

int16_t sp_3(vec2 uv) {
  return sphere(center_3, uv, r_3 + (uv.x * (t + 250) + uv.y * t) % 2);
}

uint8_t sdf_comp(int16_t sdf) {
  return sdf < 0 ? 1 : 0;
}
uint8_t fragment(vec2 uv) {
  int32_t uvx = uv.x + uv_x_offset;
  uv.x = (uvx + WIDTH) % (WIDTH * 8) - WIDTH;
  // draw spheres
  int16_t sdf = sdf_comp(sp_1(uv)) & ( (((uv.x - center_1.x) * (uv.y - center_1.y) + t/8 + 1) % 8) == 0);
  sdf ^= sdf_comp(sp_2(uv));
  sdf ^= sdf_comp(sp_3(uv));

  if(sdf > 0) return 1;
  return 0;
}

void update_uniform() {
  center_1 = {
    (fpsin(t * 60) + 4096) / (8192 / 2) + 3,
    (fpsin(t * 45) + 4096) / (8192 / 2) + HEIGHT * 0.75
  };
  r_1 = (2 + (fpsin(t * 8) + 4096) / (8192 / 4));

  center_2 = {
    (fpsin((t + 4096) * 24) + 4096) / (8192 / 4),
    (fpsin((t + 4096) * 20) + 4096) / (8192 / 4) + HEIGHT * 0.25
  };
  r_2 = (2 + (fpsin(t * 128) + 4096) / (8192 / 6));

  center_3 = {
    WIDTH * 4,
    HEIGHT / 2 - 4
  };
  r_3 = 10;// + (t / 8) % 4;
}

/*void update_screen() {
  const uint16_t FONT_WIDTH = 6;
  const uint16_t FONT_HEGHT = 8;
  const uint16_t MARGIN_HORIZONTAL = (WIDTH - FONT_WIDTH) / 2;
  const uint16_t MARGIN_VERTICAL = 2;
  //const uint16_t NUM_CHARS = (HEIGHT - 2 * MARGIN_VERTICAL) / FONT_HEIGHT - 1;
  const uint16_t NUM_CHARS = 1;

  for (uint16_t c = 0; c < NUM_CHARS; ++c) {
    //auto const* literal = char_addr[c + 2];
    auto const* literal = char_addr[c];

    const uint16_t H_OFFSET = MARGIN_VERTICAL + c * (FONT_HEIGHT + MARGIN_VERTICAL);

    for (uint16_t x = 0; x < FONT_WIDTH; ++x) {
      for (uint8_t y = 0; y < 8; ++y) {

        uint8_t cv = literal[x];
        uint8_t p = (cv >> y) & 0x1;
        if (p)
        {
            led_module.writePixel(H_OFFSET + y, x + MARGIN_HORIZONTAL, GRAPHICS_NORMAL, true);
        }
        else
        {
            led_module.writePixel(H_OFFSET + y, x + MARGIN_HORIZONTAL, GRAPHICS_NORMAL, false);
        }
      }
    }
  }
}*/
void loop() {
  float mm = (float)encoder_steps * 1.45548;
  // float mm = (float)millis()/10;
  while(mm - led_mm > LED_STEP) {
    uv_x_offset++;
    led_mm += LED_STEP;
  }

  t = millis();
  led_module.selectFont(FONT);
  const char teststring[] = "ABCDEFGHIJKLMNOPQR@";
  led_module.drawMarquee(teststring, strlen(teststring), (32 * ROW), 0);
  bool ret = false;
  while (!ret)
  {
    ret = led_module.stepMarquee(-1, 0);
    delay(100);
  }
  //led_module.stepMarquee(
  //update_uniform();
  //led_module.clearScreen(true);
  //update_screen();
  //delay(2000);
  /*
    char str[64];
    sprintf(str, "%ld", (uint32_t)mm);
    led_module.clearScreen(true);
    led_module.drawString(0, 0, str, strlen(str), GRAPHICS_NORMAL);
  */

  /*long start = millis();
    long timming = start;
    boolean flag = false;
    while (!flag) {
    if ((timming + 40) < millis()) {
      flag = led_module.stepMarquee(-1, 0);
      timming = millis();
    }
    }*/
}
